{
    "version": "https://jsonfeed.org/version/1",
    "title": "hexo-blog • All posts by \"java\" tag",
    "description": "record some markdown",
    "home_page_url": "https://ceilzcx.github.io/hexo-blog",
    "items": [
        {
            "id": "https://ceilzcx.github.io/hexo-blog/2022/05/25/java/lmax-disruptor/",
            "url": "https://ceilzcx.github.io/hexo-blog/2022/05/25/java/lmax-disruptor/",
            "title": "lmax-disruptor",
            "date_published": "2022-05-25T14:30:22.000Z",
            "content_html": "<h2 id=\"lmax-disruptor\"><a class=\"markdownIt-Anchor\" href=\"#lmax-disruptor\">#</a> LMAX Disruptor</h2>\n<h3 id=\"核心概念\"><a class=\"markdownIt-Anchor\" href=\"#核心概念\">#</a> 核心概念</h3>\n<ul>\n<li><strong>Ring Buffer</strong>：version3.0 后，环形缓存仅作为存储和更新数据（事件）</li>\n<li><strong>Sequence</strong>：序列作为识别组件位置，每个消费者维护一个自己的序列</li>\n<li><strong>Sequencer</strong>：序列器接口，有两个实现类（单生产者和多生产者），实现生产者和消费者快速传输的并发算法</li>\n<li><strong>Sequence Barrier</strong>：由  <code>Sequencer</code>  生产，包含对已发布  <code>Sequence</code>  的引用和任何依赖的消费者；也包含是否有数据需要被消费的逻辑</li>\n<li><strong>Wait Strategy</strong>：等待策略决定消费者如何等待事件的处理策略</li>\n<li><strong>Event</strong>：生产者到消费者传输的数据单位。事件完全由用户决定</li>\n<li><strong>Event Processor</strong>：主事件循环处理来自  <code>disruptor</code>  的事件，并拥有消费者序列的所有权</li>\n<li><strong>Event Handler</strong>：一个由用户实现的接口，作为  <code>disruptor</code>  的消费者</li>\n<li><strong>Producer</strong>：用户自己的代码调用  <code>disruptor</code>  进行排队</li>\n</ul>\n",
            "tags": [
                "java"
            ]
        },
        {
            "id": "https://ceilzcx.github.io/hexo-blog/2021/07/15/java/SpringBoot/",
            "url": "https://ceilzcx.github.io/hexo-blog/2021/07/15/java/SpringBoot/",
            "title": "SpringBoot",
            "date_published": "2021-07-15T15:56:32.000Z",
            "content_html": "<h2 id=\"springboot\"><a class=\"markdownIt-Anchor\" href=\"#springboot\">#</a> SpringBoot</h2>\n<h3 id=\"一-跨域问题-cors\"><a class=\"markdownIt-Anchor\" href=\"#一-跨域问题-cors\">#</a> 一、跨域问题 —— CORS</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拦截器和其他配置</span></span><br><span class=\"line\">WebMvcConfigurer</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addCorsMappings</span><span class=\"params\">(CorsRegistry registry)</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二-读取配置的几种方式\"><a class=\"markdownIt-Anchor\" href=\"#二-读取配置的几种方式\">#</a> 二、读取配置的几种方式</h3>\n<p>配置文件：Resources 下的文件，一般为 yml 文件或者 properties 文件</p>\n<ul>\n<li>\n<p>资源文件注解： <code>@PropertySource</code></p>\n</li>\n<li>\n<p>默认 yml 文件的注解： <code>@ConfigurationProperties </code></p>\n</li>\n<li>\n<p>读取对应的值： <code>@Value</code></p>\n</li>\n</ul>\n<h3 id=\"三-拦截器和过滤器\"><a class=\"markdownIt-Anchor\" href=\"#三-拦截器和过滤器\">#</a> 三、拦截器和过滤器</h3>\n<ul>\n<li>\n<p>相同点：都使用 AOP 编程思想</p>\n</li>\n<li>\n<p>不同点：</p>\n<ul>\n<li>1、Filter 是 Servlet 规范定义的，拦截器是 Spring 框架的</li>\n<li>2、过滤器在进入 tomcat 容器后，servlet 之前的预处理；拦截器在 servlet 处理后执行</li>\n<li>3、拦截器可以使用 Spring 中的各个 Bean；Filter 依赖 Servlet 容器（可以操作 Request 和 Response）</li>\n<li>4、过滤器的实现基于回调；拦截器的实现基于反射</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四-spring-event\"><a class=\"markdownIt-Anchor\" href=\"#四-spring-event\">#</a> 四、Spring Event</h3>\n<p>观察者模式、监听器模式</p>\n<p>主要组成：事件（ApplicationEvent）、监听器（ApplicationListener）、事件发布操作（publisher 方法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestEvent</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ApplicationEvent</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">TestEvent</span><span class=\"params\">(Object source, String msg)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(source);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.msg = msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMsg</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>\t<span class=\"comment\">// 需要将监听器添加到Spring容器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestEventListener</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ApplicationListener</span>&lt;TestEvent&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span><span class=\"params\">(TestEvent testEvent)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;触发监听器：&quot;</span> + testEvent.getMsg());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class EventConfig &#123;</span><br><span class=\"line\">\t// 与上述代码实现效果一样，使用注解和接口的区别</span><br><span class=\"line\">    @EventListener(classes = &#123;TestEvent.class&#125;)\t</span><br><span class=\"line\">    public void listen(TestEvent event) &#123;</span><br><span class=\"line\">        System.out.println(&quot;触发监听器：&quot; + event.getMsg());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestPublisher</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ApplicationEventPublisher publisher;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">publish</span><span class=\"params\">(String msg)</span> &#123;</span><br><span class=\"line\">        publisher.publishEvent(<span class=\"keyword\">new</span> <span class=\"title class_\">TestEvent</span>(<span class=\"built_in\">this</span>, msg));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他\"><a class=\"markdownIt-Anchor\" href=\"#其他\">#</a> 其他</h3>\n<h4 id=\"一-servlet主要处理-doget和dopost\"><a class=\"markdownIt-Anchor\" href=\"#一-servlet主要处理-doget和dopost\">#</a> 一、Servlet 主要处理 doGet 和 doPost</h4>\n<h4 id=\"配置文件脱敏\"><a class=\"markdownIt-Anchor\" href=\"#配置文件脱敏\">#</a> 配置文件脱敏</h4>\n<h5 id=\"260版本前可以使用-jasypt\"><a class=\"markdownIt-Anchor\" href=\"#260版本前可以使用-jasypt\">#</a> 2.6.0 版本前可以使用  <code>jasypt</code></h5>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.ulisesbocchio<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.0.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>配置密钥</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jasypt:</span></span><br><span class=\"line\">  <span class=\"attr\">encryptor:</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">XXX</span></span><br></pre></td></tr></table></figure>\n<p><strong>密钥放在配置文件也不是一件很安全的事情，可以通过启动时传参</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar xxx.jar -Djasypt.encryptor.password=***</span><br></pre></td></tr></table></figure>\n<p><strong>对需要加密的属性进行加密</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> StringEncryptor encryptor;</span><br><span class=\"line\">encryptor.encrypt(<span class=\"string\">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>如果遇到以下异常</p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Encryption raised an exception. A possible cause is you are using strong encryption algorithms and you have not installed the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files in this Java Virtual Machine</span><br></pre></td></tr></table></figure>\n<p>下载  <code>jce_policy-8</code> ，将文件放到对应的  <code>jre/lib/security</code>  路径下，覆盖原有的文件</p>\n<p><strong>加密后的密文写入配置</strong></p>\n<p>通过 ENC () 包裹密文并写入</p>\n<h5 id=\"260-后使用-sanitizingfunction\"><a class=\"markdownIt-Anchor\" href=\"#260-后使用-sanitizingfunction\">#</a> 2.6.0+ 后使用  <code>SanitizingFunction</code></h5>\n<p>springboot 的接口，可以自定义指定配置文件的指定规则，对配置文件进行脱敏。</p>\n<p>还在研究中，目前启动并没有执行里面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MySanitizingFunction</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> SanitizingFunction <span class=\"title function_\">sanitizingFunction</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data -&gt; &#123;</span><br><span class=\"line\">            PropertySource&lt;?&gt; propertySource = data.getPropertySource();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (propertySource.getName().contains(<span class=\"string\">&quot;xxx&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 执行相关操作</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "java"
            ]
        },
        {
            "id": "https://ceilzcx.github.io/hexo-blog/2021/07/15/java/Java/",
            "url": "https://ceilzcx.github.io/hexo-blog/2021/07/15/java/Java/",
            "title": "Java",
            "date_published": "2021-07-15T15:54:38.000Z",
            "content_html": "<h2 id=\"java语言\"><a class=\"markdownIt-Anchor\" href=\"#java语言\">#</a> Java 语言</h2>\n<h3 id=\"java基础\"><a class=\"markdownIt-Anchor\" href=\"#java基础\">#</a> Java 基础</h3>\n<h4 id=\"一-int-和-integer-区别和比较\"><a class=\"markdownIt-Anchor\" href=\"#一-int-和-integer-区别和比较\">#</a> 一、 <code>int</code>  和  <code>Integer</code>  区别和比较</h4>\n<p><code>int</code>  为基本类型， <code>Integer</code>  为对象类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i01</span> <span class=\"operator\">=</span> <span class=\"number\">59</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i02</span> <span class=\"operator\">=</span> <span class=\"number\">59</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i03</span> <span class=\"operator\">=</span> Integer.valueOf(<span class=\"number\">59</span>);\t<span class=\"comment\">// 和 Integer i03 = 59一样</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i04</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">59</span>);</span><br><span class=\"line\">System.out.println(i01 == i02);\t\t<span class=\"comment\">// true，int类型和Integer类型进行比较时，Integer会自动拆箱，变成int值比较</span></span><br><span class=\"line\">System.out.println(i01 == i03);\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(i01 == i04);\t\t<span class=\"comment\">// false，i04生成了新的对象</span></span><br><span class=\"line\">System.out.println(i03 == i04);\t\t<span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"二-string-和-stringbuffer-和-stringbuilder\"><a class=\"markdownIt-Anchor\" href=\"#二-string-和-stringbuffer-和-stringbuilder\">#</a> 二、 <code>String</code>  和  <code>StringBuffer</code>  和  <code>StringBuilder</code></h4>\n<ul>\n<li><code>String</code> ：<strong>不可改变的字符串</strong></li>\n<li><code>StringBuffer</code>  ：修改字符串，动态构建字符串。方法添加  <code>Synchronized</code>  修饰符</li>\n<li><code>StringBuilder</code> ：线程不安全，速度更快</li>\n</ul>\n<h4 id=\"三-synchronized-和-lock\"><a class=\"markdownIt-Anchor\" href=\"#三-synchronized-和-lock\">#</a> 三、 <code>Synchronized</code>  和  <code>Lock</code></h4>\n<ul>\n<li>\n<p><code>Synchronized</code> ：保证最多一个线程同时执行该代码块，抛出异常时，主动释放锁。等待锁的线程无法终端，会一直等待响应。</p>\n<p><strong>修饰静态方法将会锁住类，修饰普通方法会锁住对象的实例。</strong></p>\n</li>\n<li>\n<p><code>Lock</code> ：需要  <code>finally</code>  添加  <code>unlock</code>  释放锁。</p>\n</li>\n</ul>\n<h4 id=\"四-六原则和一法则\"><a class=\"markdownIt-Anchor\" href=\"#四-六原则和一法则\">#</a> 四、六原则和一法则</h4>\n<ul>\n<li>单一职责原则：类实现高内聚，最实现自己的功能</li>\n<li>开闭原则：对外扩展（通过派生新类实现新功能），对内关闭（类本身不进行修改）</li>\n<li>依赖倒转原则：面向接口编程。</li>\n<li>里氏替换原则：任何时候都可以用子类型替换掉父类型（猫不能继承狗）。</li>\n<li>接口隔离原则：接口要小而专，绝不能大而全。</li>\n<li>合成聚合复用原则：优先使用聚合或合成关系复用代码。</li>\n<li>迪米特法则：一个对象应当对其他对象有尽可能少的了解。</li>\n</ul>\n<h4 id=\"五-请说明一下final-finally-finalize的区别\"><a class=\"markdownIt-Anchor\" href=\"#五-请说明一下final-finally-finalize的区别\">#</a> 五、请说明一下 final, finally, finalize 的区别。</h4>\n<ul>\n<li><code>final</code> ： 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li>\n<li><code>finally</code> ：是异常处理语句结构的一部分，表示总是执行。</li>\n<li><code>finalize</code> ：是  <code>Object</code>  类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源</li>\n</ul>\n<h3 id=\"数据结构\"><a class=\"markdownIt-Anchor\" href=\"#数据结构\">#</a> 数据结构</h3>\n<h4 id=\"一-hashtable\"><a class=\"markdownIt-Anchor\" href=\"#一-hashtable\">#</a> 一、 <code>Hashtable</code></h4>\n<h5 id=\"1简介\"><a class=\"markdownIt-Anchor\" href=\"#1简介\">#</a> 1）简介</h5>\n<p>散列表，存储方式：键值对（key-value）映射。</p>\n<p><strong>继承于 Dictionary</strong>，实现了<strong> Map 接口</strong></p>\n<p>函数同步（操作的函数都有 <code>synchronized </code> 修饰符），线程安全</p>\n<p>key 和 value 都不能为 null</p>\n<p><code>Hashtable</code>  的实例有两个参数影响其性能：<strong>初始容量 和 加载因子</strong>。</p>\n<p>数据通过单项链表的实现保存，所有值存在 <code>Entry[] table</code>  中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span>&lt;K, V&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;\t<span class=\"comment\">// 唯一</span></span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Entry&lt;K, V&gt; next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"servlet\"><a class=\"markdownIt-Anchor\" href=\"#servlet\">#</a> Servlet</h3>\n<h4 id=\"一-生命周期\"><a class=\"markdownIt-Anchor\" href=\"#一-生命周期\">#</a> 一、生命周期</h4>\n<ul>\n<li>\n<p>初始化  <code>init()</code></p>\n<p><strong>第一次调用 Servlet 时调用</strong></p>\n</li>\n<li>\n<p><code>service()</code></p>\n<p>执行实际任务的方法。每次服务器接收到一个 Servlet 请求，产生一个新的线程并调用服务。通过请求的请求类型选择调用对应的方法，例：doGet，doPost</p>\n</li>\n<li>\n<p><code>destroy()</code></p>\n<p>destroy () 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy () 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p>\n<p>在调用 destroy () 方法之后，servlet 对象被标记为垃圾回收</p>\n</li>\n</ul>\n<h3 id=\"serviceloader\"><a class=\"markdownIt-Anchor\" href=\"#serviceloader\">#</a> ServiceLoader</h3>\n<blockquote>\n<p>加载接口下的所有实现类</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServiceLoader.load(Test.class, classLoader);</span><br></pre></td></tr></table></figure>\n<p><strong>需要将  <code>META-INF/services</code>  目录下配置文件</strong>，文件名称就是接口名，文件内容就是具体实现类</p>\n<p>其他：在  <code>Spring</code>  框架中，  <code>getBeansOfType()</code>  也可以实现</p>\n",
            "tags": [
                "java"
            ]
        }
    ]
}